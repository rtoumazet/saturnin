// 
// spti.h
// Saturnin
//
// Copyright (c) 2003-2016 Renaud Toumazet
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file	spti.h
///
/// \brief	Declares the spti class. 
////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>
#include <string>

namespace saturnin {
namespace cdrom {

const uint8_t SptiTimeout = 5;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// \class	Spti
///
/// \brief	Spti class. 
///
/// \author	Runik
/// \date	01/03/2010
////////////////////////////////////////////////////////////////////////////////////////////////////
class Spti {
    public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static bool initialize()
    ///
    /// \brief	Initialises this object. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \return	true if initialization is successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static bool initialize();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static void deInitialize()
    ///
    /// \brief	Releases everything related to this object. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static void shutdown();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static int32_t scanBus()
    ///
    /// \brief	Scans the bus. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \return	number of drive. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static int32_t scanBus();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static void test()
    ///
    /// \brief	Unused. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static void test();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static string readSector(const uint32_t & fad, const int32_t & nb)
    ///
    /// \brief	Reads sector(s). 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \param	fad	FAD where to read the sector. 
    /// \param	nb	Number of sectors to read. 
    ///
    /// \return	The sector. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static std::string readSector(const std::uint32_t & fad, const std::int32_t & nb);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static string readOneSector(const uint32_t & fad)
    ///
    /// \brief	Reads one sector. 
    ///
    /// \author	Runik
    /// \date	19/03/2015
    ///
    /// \param	fad	FAD where to read the sector. 
    ///
    /// \return	Sector read. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static std::string readOneSector(const std::uint32_t & fad);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static void inquiry(const HANDLE & hHdl, SCSI_DriveInfo & diDrive)
    ///
    /// \brief	Inquiries the parameter drive. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \param	hHdl			Handle. 
    /// \param [in,out]	diDrive	The drive information. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static void inquiry(const HANDLE & hHdl, ScsiDriveInfo & diDrive);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static void getAdapterAddress(const HANDLE & hHdl, SCSI_DriveInfo & diDrive)
    ///
    /// \brief	Fills the SCSI_Drive structure with the drive address. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \param	hHdl			Handle. 
    /// \param [in,out]	diDrive	the drive structure. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static void	getAdapterAddress(const HANDLE & hHdl, ScsiDriveInfo & diDrive);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \fn	static bool readToc(SCSI_TOC& TOCData)
    ///
    /// \brief	Reads the CD TOC. 
    ///
    /// \author	Runik
    /// \date	01/03/2010
    ///
    /// \param [in,out]	TOCData	information describing the toc. 
    ///
    /// \return	true if it succeeds, false if it fails. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    static bool	readToc(ScsiToc& TOCData);
};
}
}